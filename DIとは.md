# DI（依存性注入）とは

## 目標
- [ ] DIの概念について自分の言葉で説明できる
- [ ] DIがの概念のコードでの実現を紐づけることができる

## キーワード
- DI
- 「依存」と「注入」
- @Autowired

　/h3 演習：DIについて調べてみよう(5分)
  **全然わからなすぎる概念なので、いったん自由に調べてもらう時間を設ける、教科書を読ませる時間にしても可**

## 既存コードをDIを使い改修してみよう
まず、次のコードを少し確認してみます。

```java
@Controller
public class TestController {
    
    private TestService testService = new TestService();

    @GetMapping("/home")
    public String home(Model model){
        int randNum = testService.getRandNum();
        model.addAttribute("num", randNum);
        return "home";
    }
}
```

```java
@Service
public class TestService {
    
    public int getRandNum(){
        return (int)(Math.random() * 100);
    }
}
```

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
    <head>
        <title>Home</title>
    </head>
    <body>
        <h1>Number: <span th:text="${num}"></span></h1>
    </body>
</html>
```

ここまでの授業の振り返りにもなりますが、以下のような流れでランダムな数字がブラウザに表示されるコードになっています。

---

ここに流れの画像を表示

---

このコードを、DIの考え方に基づいて実装した内容が次のコードになります。今回編集するのはControllerの部分だけです。

```diff
@Controller
public class TestController {
    
-   private TestService testService = new TestService();

+   @Autowired
+   private TestService testService;

    @GetMapping("/home")
    public String home(Model model){
        int randNum = testService.getRandNum();
        model.addAttribute("num", randNum);
        return "home";
    }
}
```

よくわからないアノテーションがついたことと、サービスクラスのインスタンス化をしていないようです。インスタンス化をしていないので、この`testService`になにも代入されていないように見えますが、なぜかちゃんとこれで動作します。関数`getRandNum()`も正常に使えるようです。<br>
このコードの変更をもとに、DIについて考えてみましょう。以下の疑問を解消しながら、SpringにおけるDIの考え方を身につけよう！

- なぜインスタンス化していないのに`testService`が使えるの？
- `@Autowired`とは？

## DIの基本概念
DI（Dependency Injection：依存性注入）は、オブジェクト指向プログラミングでの設計における考え方の一つです。DIは、オブジェクトの依存関係を外部から注入することで、コードの柔軟性と再利用性を高めることを目的としています。

いまいちよくわからない説明かと思いますが、大事なのは**オブジェクトの依存関係を（外部から）注入**してくれるモノだということです。
注入は次のようなイメージです。依存元（Controller）から依存先（Service）に対して、どうせ絶対使うんだから勝手にSpring Boot側でインスタンス化しといてあげるぜ（注入）！というイメージがついていればOK！

~~ ここに画像を挿入 ~~


> **オブジェクトの依存関係とは？**<br>
簡単に言うと、あるオブジェクトが他のオブジェクトの機能を使うことを、依存関係にあるといいます。<br>
今回の例で行くと、TestControllerはTestService内の関数を使っている状態なので、TestControllerはTestServiceに依存している、と言えます。難しそうな概念ですが、言語関係なく普通に行われることだよなと思ってくれれば大丈夫です。


## コードと比較してみよう
DIの概念がなんとなくわかったところで、先ほどのコードで出た二つの疑問について、改めて考えてみましょう。
- なぜインスタンス化していないのに`testService`が使えるの？<br>
→ DIによってSpring Boot側で勝手にインスタンス化してくれているから。
- `@Autowired`とは？<br>
→ DIを使うときに自動で注入させたい部分につける記述。これがついている物はDI対象としてSpring Bootが認識して、勝手に注入を行ってくれる。


改めてここまでで、DIについてもう一度まとめておきます。
DI（依存性注入）とはその言葉の通り、依存しているクラスを外部から
注入するという考え方です。
コードの例と照らし合わせると、ControllerがServiceに依存しており、そのクラスとは直接は関係のないSpring Boot側が勝手にインスタンス化をしてくれる部分でDIの考え方が使われています。

　~~ ここにDIの図を入れる ~~ 

このDIを管理している部分をDIコンテナといいます。@Autowiredがついている記述があったときに、Spring BootのDIコンテナがそれを検出して、注入するのにふさわしいクラスを勝手にインスタンス化してくれる、という仕組みになっているわけです。

## DIで何が便利なの？
別に毎回普通にインスタンス化すればよくない？と思ったあなた。正解です。
上のコード例でもありましたが、記述がちょっと減るくらい、むしろ`@Autowired`のせいで若干行数自体は少し増えているまであるかも？
実はDIのメリットは、ここまで教えた内容だけでは少し理解しにくいところにあります。いったんこの授業の中では、DIという考え方があり、その考え方を元に勝手にインスタンス化をしてくれる仕組みがSpring Bootには備わっている、ということが理解できればOKです！

 /h3 演習：DIを使った実装をやってみよう
 - 以前のコードをDIを使った実装にしてみる。どこをどう変更させるかは、生徒側に考えてもらう。

 ## 補足：DIの便利なところ概要だけ
 DIのおかげでいろいろなことが便利になるのですが、そのうちの2つの部分だけをかいつまんで説明してみます。当然ここで理解しきる必要はありません。もしDIがよくわかってない状態であれば、この内容は飛ばしてもらって大丈夫です。

 ### テストのときのクラスの切り替えが簡単！
 コーデイングを行った後は、そのコードが想定通り動作するか、テストコードを書いて検証する、という手順を行います。
 このとき基本的にはテストするコードは一つずつ行うのが基本です。コントローラをテストしたいのであればコントローラ用のテストコードを、サービスをテストしたいのであればサービス用のテストコードを記述するのが基本になります。
 しかしここで、コントローラがサービスに依存している状態だと、少し困ったことになってしまいます。コントローラが正常に動いているかどうかの確認をしたいのに、もしかしたらサービスクラスがおかしいせいで正常に動かない部分があるかもしれません。
 これを解消するために、「モック」という考え方があります。
 簡単に言うと、サービスクラスの動作を、テスト用に一定の値しか返さないようにしちゃえ！という考え方です。モックの説明や実装はここでは割愛しますが、コントローラのテストをするときはここで作ったモックで、実際の動作の時はもともと作っていたサービスを使って、という形で切り替えて使うことが一般的です。
 ここで、切り替えるときに毎回この部分を書き換えるのでしょうか？
 ```java
// テスト用に、TestServiceMockというクラスを用意している想定です

 @Controller
 public class TestController(){

    // 普通の動作はこっち
    private TestService testService = new TestService();

    // テスト用の動作はこっち
    private TestService testServiceMock = new TestServiceMock();
 }
 ```
めんどくさいですよね。毎回変えなきゃいけないと、そこで書き換えのミスが起こってしまう可能性もあります。
そこでDIです。細かい実装は省きますが、DIをうまく使うことで、記述は下の状態のまま、普通の動作/テストの動作を切り替えることが可能になります。

 ```java
 @Controller
 public class TestController(){

    @Autowired
    private TestService testService;
 }
 ```

 Autowiredのおかげで、コントローラクラス自体はインスタンス化を行わず、Spring Boot側で自動的にインスタンス化を行います。このときに、Spring Boot側で「普通の時はTestService, テストのときはTestServiceMock」を注入するように設定をしておけば、コントローラの記述を変えることなくテストを実行することができます。
 このように、テスト時だけクラスを切り替えたい！というときに非常に便利です。実は切り替えの設定自体もSpring Bootはある程度自動でやってくれるので、いちいち切り替えを意識せずともこの動作を実現できる、というメリットもあります。

 ### クラスを一括管理できる！
 DIで意外と大事になる考えが、依存性を「外部」から注入できるということ。つまり各クラスがそれぞれ使うときに依存するクラスをインスタンス化するのではなく、別の所で一括で管理できる！ということです。
 Webアプリケーションを扱う中で、意外と気にしなければいけないのが、複数の場所から同時にアクセスされてもちゃんと動くようにできること。これをうまく管理するために、一括で何かを管理する場所があると都合がいいのです。自動で管理してくれている部分なので実際にコーディングしている時には気づきにくいですが、すごく大事な部分になります。
